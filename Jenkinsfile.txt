import groovy.json.JsonSlurperClassic
import groovy.json.JsonSlurper
properties([
    pipelineTriggers([
        issueCommentTrigger('.*test this please.*')
    ])
])
node {
    stage('Echo stuff pointlessly') {
        // Parse the payload safely
        def payload = new JsonSlurper().parseText(params.payload ?: '{}')

        // Safely get build causes and convert them to a readable string
        def causes = currentBuild.getBuildCauses()
        echo "Current build causes: ${causes.collect { it.toString() }.join(', ')}"
        def triggerCause = currentBuild.rawBuild.getCause(org.jenkinsci.plugins.pipeline.github.trigger.IssueCommentCause)

        if (triggerCause) {
            echo("Build was started by ${triggerCause.userLogin}, who wrote: " +
                 "\"${triggerCause.comment}\", which matches the " +
                 "\"${triggerCause.triggerPattern}\" trigger pattern.")
        } else {
            echo('Build was not started by a comment trigger.')
            // Add a comment to notify the user how to trigger builds with test classes
            echo 'Adding comment to the PR.'
            // Use GitHub CLI or a Jenkins plugin to add a comment
            // Example GitHub CLI command: gh issue comment $PR_NUMBER --body "To test Classes Write 'test this please.' followed by comma separated test class names."
            return // Stop execution here
        }

        // Extract test class names from the comment
        def commentText = triggerCause.comment
        def match = (commentText =~ /test this please\.(.*)/)
        if (!match) {
            error "No test classes specified in the comment. Example: 'test this please. TestClass1, TestClass2'"
        }
        def testClasses = match[0][1].trim().split(/\s*,\s*/)
        echo "Extracted test classes: ${testClasses.join(', ')}"

        // Store test classes to be used later
        env.TEST_CLASSES = testClasses.join(',')
    }
}

node {
    def BUILD_NUMBER = env.BUILD_NUMBER
    def RUN_ARTIFACT_DIR = "tests/${BUILD_NUMBER}"
    def SFDC_USERNAME
    def CONNECTED_APP_CONSUMER_KEY = "3MVG9WVXk15qiz1J7cu9IlavNr.AWS435dwUVopFudA.O5DGhZ7QoP49guqLmzqmgbA_JknOI4DFsPogdVRv9"
    def HUB_ORG = "chandradev1@kloudrac.com"
    def JWT_KEY_CRED_ID = "1fde5a5a-3987-4fbb-b1a6-a236ee570232"
    def DEPLOYDIR = 'force-app/main/default/'
    def SFDC_HOST = env.SFDC_HOST ?: "https://login.salesforce.com"
    def TEST_LEVEL = 'RunSpecifiedTests'
    def toolbelt = tool 'toolbelt'
    def changedFiles
    def salesforceFiles
    def execute = true

    stage('Cleanup Workspace') {
        cleanWs()
    }

    stage('Checkout Source') {
        if (env.BRANCH_NAME.startsWith('PR')) {
            checkout([$class: 'GitSCM', branches: [[name: '*/SandBranch']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'jenkinstestcpr', url: 'https://github.com/chandra00789/chandradev1.git']]])
            bat(script: """git fetch origin main""")
            bat(script: """git checkout main""")
            bat(script: """git checkout SandBranch""")
            changedFiles = bat(
                script: """git diff --name-only main""",
                returnStdout: true
            ).trim().split('\n')
            echo "Changed files: ${changedFiles.join(', ')}"
        } else if (env.BRANCH_NAME == 'main') {
            checkout([$class: 'GitSCM', branches: [[name: '*/main']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'jenkinstestcpr', url: 'https://github.com/chandra00789/chandradev1.git']]])
            bat(script: """git fetch origin main""")
            bat(script: """git checkout -B main origin/main""")
            changedFiles = bat(
                script: """git diff --name-only HEAD~1 main""",
                returnStdout: true
            ).trim().split('\n')
            echo "Changed files: ${changedFiles.join(', ')}"
        }
    }

    stage('Create Package for Pull Request') {
        salesforceFiles = changedFiles.findAll { filePath ->
            filePath.contains('force-app')
        }
        echo "Filtered Salesforce Files: ${salesforceFiles.join(', ')}"

        if (salesforceFiles.isEmpty()) {
            echo "No Salesforce metadata files to deploy."
            execute = false
        }
    }

    if (execute) {
        withEnv(["HOME=${env.WORKSPACE}"]) {
            echo "Workspace path is: ${env.WORKSPACE}"
            withCredentials([file(credentialsId: JWT_KEY_CRED_ID, variable: 'JWT_KEY_CRED_ID')]) {
                stage('Authorize to Salesforce') {
                    def rc = bat(
                        script: """
                        "C:\\Program Files\\sf\\bin\\sfdx" auth:jwt:grant --instanceurl https://login.salesforce.com --clientid ${CONNECTED_APP_CONSUMER_KEY} --jwtkeyfile "C:\\openssl\\bin\\server.key" --username ${HUB_ORG} --setalias chandradev1
                        """,
                        returnStatus: true
                    )
                    if (rc != 0) {
                        error "Authorization failed."
                    }
                    echo "Authorization successful."
                }

                stage('Deploy or Validate') {
                    def validateCommand = """
                    "C:\\Program Files\\sf\\bin\\sfdx" force:source:deploy --checkonly -p "${salesforceFiles.join(',')}" --targetusername chandradev1 --testlevel ${TEST_LEVEL} --runtests "${env.TEST_CLASSES}" --wait 10 --verbose --json
                    """
                    def rc = bat(validateCommand, returnStatus: true)
                    if (rc == 0) {
                        echo "Validation/Deployment succeeded."
                    } else {
                        error "Validation/Deployment failed. Check logs for details."
                    }
                }
            }
        }
    }
}
