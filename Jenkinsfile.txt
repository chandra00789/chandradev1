import groovy.json.JsonSlurperClassic
import groovy.json.JsonOutput

properties([
    pipelineTriggers([
        issueCommentTrigger('Initiate Validation:\\s*\\[(.*?)\\]\\s*') // Comment trigger
    ])
])

node {
        stage('Cleanup Workspace') {

                cleanWs() // Clean up the workspace
        }
	
        stage('Initialize') {
                
                    // Ensure the project directory exists
                    env.run = true
					def projectName = env.JOB_NAME.split('/')[0]
                    env.PROJECT_NAME = projectName
					env.CONFIG_DIR = "${env.JENKINS_HOME}\\workspace\\${env.PROJECT_NAME}"
                    env.CONFIG_FILE = "${env.CONFIG_DIR}\\config.json"

                    echo "Project Name: ${env.PROJECT_NAME}"
                    echo "Config File Path: ${env.CONFIG_FILE}"
                    new File(env.CONFIG_DIR).mkdirs()
					
                    // Read the configuration file
                    if (fileExists(CONFIG_FILE)) {
                        def config = readProjectConfig(CONFIG_FILE)
                        echo "${config}"
                        def isPR = env.BRANCH_NAME.startsWith('PR')
                        if (isPR) {
                            branchConfig = config[pullRequest.base] 
                        } else {
                            branchConfig = config[env.BRANCH_NAME] 
                        }
                        
                    }
                    if(!fileExists(CONFIG_FILE) || !branchConfig){
                        echo "No configuration file found. Exiting build."
                        currentBuild.result = 'SUCCESS'
                        env.run = false
                        return
                    }
            
            
        }
        stage('Checkout Source') {
                    echo "${env.run}"
                    if(!env.run)
                    return
                    def isPR = env.BRANCH_NAME.startsWith('PR')
                    if (isPR) {
                        checkoutPRSource()
                    } else {
                        checkoutBranchSource()
                    }
                
        }
        stage('Process Trigger and Build Logic') {
                    if(!env.run)
                    return
                    def isPR = env.BRANCH_NAME.startsWith('PR')
                    if (isPR) {
                        handlePullRequest(config)
                    } else {
                        handleNonPullRequest(config)
                    }
        }
}

def readProjectConfig(filePath) {
    def jsonContent = readFile(filePath)
    config = readJSON text: jsonContent
	return config
}

def checkoutPRSource() {
    echo "Checking out PR source branch..."
    checkout([
        $class: 'GitSCM',
        branches: [[name: env.CHANGE_BRANCH]],
        userRemoteConfigs: [[url: env.GIT_URL]],
        extensions: [[$class: 'CleanBeforeCheckout']]
    ])
    echo "Checked out PR source branch: ${env.CHANGE_BRANCH}"
}

def checkoutBranchSource() {
    
    checkout scm
}

def handlePullRequest(Config) {
    def targetBranch = pullRequest.base // Extract target branch for the PR
    def targetBranchConfig = Config[targetBranch]

    if (!targetBranchConfig) {
        echo "No config found for target branch: ${targetBranch}. Exiting build."
        currentBuild.result = 'SUCCESS'
        env.run = false
        return
    }

    def buildType = Config.buildType ?: 'manual'
    def isManual = buildType == 'manual'

    def triggerCause = currentBuild.rawBuild.getCause(org.jenkinsci.plugins.pipeline.github.trigger.IssueCommentCause)
    if (triggerCause) {
        echo "Build triggered by comment: ${triggerCause.comment}"
        if (!isManual) {
            def prevBuildStatus = getPreviousBuildStatus()
            echo "Exiting with previous build status: ${prevBuildStatus}"
            currentBuild.result = prevBuildStatus
            env.run = false
            return
        }
        def changedFiles = getChangedFilesPR()
        authorizeTargetOrg(targetBranchConfig)
        def commentText = triggerCause.comment
        def match = (commentText =~ /Initiate Validation:\s*(.*?)\s*$/)
        if (!match || match[0][1].trim().isEmpty()) {
            error "No test classes specified in the comment. Example: 'Initiate Validation: TestClass1, TestClass2, TestClass3'"
        }

        def testClasses = match[0][1].split(/\s*,\s*/).collect { it.trim() }
        echo "Extracted test classes: ${testClasses.join(', ')}"

        // Store test classes in the environment for later use
        env.TEST_CLASSES = testClasses.join(',')
        RunSpecifiedTests(changedFiles,testClasses,targetBranchConfig)

        
    } else
    {
        if (isManual) {
            error "Automatic builds must be triggered automatically."
        }
        def changedFiles = getChangedFilesPR()
        authorizeTargetOrg(targetBranchConfig)

        def testLevel = targetBranchConfig.testLevel
        switch (testLevel) {
            case 'RunAllTests':
                validateAllTests(targetBranchConfig, changedFiles)
                break
            case 'RunLocalTests':
                validateLocalTests(targetBranchConfig, changedFiles)
                break
            default:
                validateDefaultTests(targetBranchConfig, changedFiles)
                break
        }

    }

    
}

def handleNonPullRequest(branchConfig) {

    def changedFiles = getChangedFilesNonPR()
    if (changedFiles.isEmpty()) {
        echo "No changes detected. Exiting build."
        currentBuild.result = 'SUCCESS'
        env.run = false
        return
    }

    authorizeTargetOrg(branchConfig)
    deployChangedFiles(changedFiles, branchConfig)
    
    def deploymentIdFile = "${env.CONFIG_DIR}\\${env.BRANCH_NAME}_deploymentid.txt"
    if (fileExists(deploymentIdFile)) {
        def deploymentId = readFile(deploymentIdFile).trim()
        echo "Found Deployment ID: ${deploymentId}. Attempting quick deploy."
        if (!quickDeploy(deploymentId, branchConfig)) {
            echo "Quick deploy failed. Deploying full package."
            deploySalesforcePackage(branchConfig )
        }
    } else {
        echo "No Deployment ID found for branch: ${env.BRANCH_NAME}. Exiting build."
        currentBuild.result = 'SUCCESS'
        return
    }
}

def getChangedFilesPR() {
    def files = []
    for (commitFile in pullRequest.files) {
        files.add(commitFile.filename)
    }
    def salesforceFiles = files.findAll { filePath ->
        filePath.contains('force-app')
    }
    echo "Filtered Salesforce Files for PR: ${salesforceFiles.join(', ')}"
    return salesforceFiles
}

def getChangedFilesNonPR() {
    def changes = []
    def changeLogSets = currentBuild.changeSets
    for (changeLog in changeLogSets) {
        for (entry in changeLog.items) {
            entry.affectedFiles.each { file ->
                changes.add(file.path)
            }
        }
    }
    def salesforceFiles = changes.findAll { filePath ->
        filePath.contains('force-app')
    }
    echo "Filtered Salesforce Files for Non-PR: ${salesforceFiles.join(', ')}"
    return salesforceFiles
}

def authorizeTargetOrg(branchConfig) {
    def authCommand = """
        "C:\\Program Files\\sf\\bin\\sfdx" auth:jwt:grant \
        --clientid ${branchConfig.clientId} \
        --jwtkeyfile ${branchConfig.keyFile} \
        --username ${branchConfig.username} \
        --instanceurl ${branchConfig.instanceUrl}
    """
    def rc = bat(returnStatus: true, script: authCommand)
    if (rc != 0) {
        error "Authorization failed for target org."
    } else {
        echo "Successfully authorized target org."
    }
}

def validateAllTests(config, changedFiles) {
    validateSalesforcePackage(config, 'RunAllTests', changedFiles)
}

def validateLocalTests(config, changedFiles) {
    validateSalesforcePackage(config, 'RunLocalTests', changedFiles)
}

def validateDefaultTests(config, changedFiles) {
    validateSalesforcePackage(config, 'Default', changedFiles)
}

def validateSalesforcePackage(config, testLevel, changedFiles) {
    def filesToDeploy = changedFiles?.join(',')
    def validateCommand = """
        "C:\\Program Files\\sf\\bin\\sfdx" force:source:deploy \
        --checkonly -p ${filesToDeploy} \
        --targetusername ${config.org} \
        --testlevel ${testLevel} \
        --wait 10 --verbose --json
    """
    def rc = bat(returnStatus: true, script: validateCommand).trim()
    def jsonStart = rc.indexOf('{')
		    def jsonEnd = rc.lastIndexOf('}')
		    if (jsonStart >= 0 && jsonEnd >= jsonStart) {
		        def jsonOutput = rc.substring(jsonStart, jsonEnd + 1).trim()
			
		        
			def serializableData = readJSON text: jsonOutput
			jsonOutput = null
		        // Log warnings
		        if (serializableData.warnings?.size() > 0) {
		            echo "Warnings: ${serializableData.warnings}"
		        }
		
		        // Validate deployment status
		        if (serializableData.result.status == 'Succeeded' && serializableData.result.success == true) {
		            echo "Validation succeeded."
		            
			def comment = pullRequest.comment("Validation succeeded. Deployment ID : ${serializableData.result.id}")
		            echo "Stored Deployment ID: ${serializableData.result.id}"
                    def deploymentIdFile = "${env.CONFIG_DIR}\\${env.BRANCH_NAME}_deploymentid.txt"
                    writeFile(file: deploymentIdFile, text: "${serializableData.result.id}")
			    
			    echo "Deployment ID has been saved to deployment_id.txt and archived."
		        } else {
			echo "Validation failed. JSON status: ${serializableData.result.status}, success: ${serializableData.result.success}"
		            def comment = pullRequest.comment("Validation failed. JSON status: ${serializableData.result.status}, success: ${serializableData.result.success} Deployment ID : ${serializableData.result.id}")
			error "Validation failed. JSON status: ${serializableData.result.status}, success: ${serializableData.result.success} Deployment ID : ${serializableData.result.id}"
		        }
			serializableData = null
		    } else {
		        error "Failed to extract JSON from the output."
		    }
    
}

def deploySalesforcePackage(config) {
    def deployCommand = """
        "C:\\Program Files\\sf\\bin\\sfdx" force:mdapi:deploy \
        --deploydir force-app/main/default \
        --targetusername ${config.org} \
        --testlevel RunLocalTests --wait 10
    """
    def rc = bat(returnStatus: true, script: deployCommand)
    if (rc != 0) {
        error "Deployment failed."
    } else {
        echo "Deployment succeeded."
    }
}

def quickDeploy(deploymentId, config) {
    def quickDeployCommand = """
        "C:\\Program Files\\sf\\bin\\sfdx" force:mdapi:deploy \
        --validateddeployrequestid ${deploymentId} \
        --targetusername ${config.org} --wait 10
    """
    def rc = bat(returnStatus: true, script: quickDeployCommand)
    return rc == 0
}

def getPreviousBuildStatus() {
    def previousBuild = currentBuild.previousBuild
    return previousBuild ? previousBuild.result : 'SUCCESS'
}

def RunSpecifiedTests(changedFiles, testClasses, targetBranchConfig) {
    def testClassList = testClasses.join(',')
    echo "Running specified tests: ${testClassList}"

    def validateCommand = """
        "C:\\Program Files\\sf\\bin\\sfdx" force:source:deploy \
        --checkonly -p ${changedFiles}
        --targetusername ${targetBranchConfig.org} \
        --testlevel RunSpecifiedTests \
        --runtests ${testClassList} \
        --wait 10 --verbose --json
    """

    def rc = bat(returnStatus: true, script: validateCommand).trim()
    def jsonStart = rc.indexOf('{')
    def jsonEnd = rc.lastIndexOf('}')
    if (jsonStart >= 0 && jsonEnd >= jsonStart) {
        def jsonOutput = rc.substring(jsonStart, jsonEnd + 1).trim()
        def serializableData = readJSON text: jsonOutput

        if (serializableData.result.status == 'Succeeded' && serializableData.result.success == true) {
            echo "Specified tests succeeded."
            def deploymentId = serializableData.result.id
            def deploymentIdFile = "${env.CONFIG_DIR}\\${env.BRANCH_NAME}_deploymentid.txt"
            writeFile(file: deploymentIdFile, text: deploymentId)
            echo "Stored Deployment ID: ${deploymentId} for successful validation."
        } else {
            echo "Specified tests failed. JSON status: ${serializableData.result.status}, success: ${serializableData.result.success}"
            error "Validation failed for specified tests."
        }
    } else {
        error "Failed to extract JSON from the output."
    }
}
